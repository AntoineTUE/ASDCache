{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ASDCache","text":"<p><code>ASDCache</code> is a Python project to retrieve data from the NIST Atomic Spectra Database (ASD), using caching for fast, efficient data handling.</p> <p>To make the most use out of the cache, <code>ASDCache</code> is opinionated in the information it retrieves from the ASD; it always requests the same schema of information and locally computes additional fields, to provide a more 'machine-useable' experience.</p> <p>It also coerces most of the retrieved data to be of a strictly numeric type, which strips out footnotes and annotations, but preserves e.g. bibliographic reference labels.</p> <p>You should thus still be sure to check and attribute the NIST ASD when making use of <code>ASDCache</code>!</p> <p>The main goals and benefits of <code>ASDCache</code> are:</p> <ul> <li> Make the data from the NIST ASD locally accessible as a Dataframe for use in analysis of spectra</li> <li> Retrieve a consistent schema of the data that represents the 'human readable' format, but enforce strictly numeric data for important columns<ul> <li> This removes footnotes and other annotations, be sure to check the ASD itself as well for this information.</li> </ul> </li> <li> Use caching to dramatically speed up data retrieval, from minutes down to milliseconds in some cases<ul> <li> Cache time-to-live is 1 week by default, meaning you still get updates to the ASD in a reasonable time frame</li> <li> The cache time-to-live can be adjusted</li> </ul> </li> <li> Cache data to allow working offline, or even transfering the ASD data to an offline system.<ul> <li> The cache is only updated when a request for new data succeeds</li> </ul> </li> <li> Limit repeated queries for the same information, avoiding network overhead and server load.</li> </ul> <p><code>ASDCache</code> is not affiliated with NIST or the NIST ASD in any way, it simply tries to help make it more accessible.</p>"},{"location":"#installing","title":"Installing","text":"<p><code>ASDCache</code> can be installed with <code>pip</code>.</p> <pre><code>pip install ASDCache\n</code></pre> <p>Further optional features can be installed by specifying the <code>polars</code> or <code>docs</code> feature flag, as defined in pyproject.toml.</p> <p>To install all dependencies to locally serve and update the documentation for instance, you can run:</p> <pre><code>pip install ASDCache[docs]\n</code></pre> <p>Installing the <code>polars</code> feature is not required, in case <code>polars</code> is already installed in the active environment, it is possible to use <code>polars</code> instead of <code>pandas</code> as a Dataframe backend for <code>ASDCache</code>.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation for <code>ASDCache</code> is available on this page.</p>"},{"location":"#example","title":"Example","text":"<p>A brief example below demonstrates how to use <code>SpectraCache</code> to query the NIST ASD for spectroscopic data for different species and plot their respective relative intensities.</p> <p>Note that these relative intensities are in principle not comparable between different species or sources and merely serve as a guide.</p> <p>More elaborate examples can be found in the example section of the documentation</p> <pre><code>from ASDCache import SpectraCache, BibCache\nimport matplotlib.pyplot as plt\n\nnist = ASDCache()\nlines_H_I = nist.fetch(\"H I\")\n\n\nplt.plot(lines_H_I['obs_wl_air(nm)'], lines_H_I['intens'], label=f\"{lines_H_I['element'].unique()[0]} {lines_H_I['sp_num'].unique()[0]}\")\n\n\nnist.fetch(\"O I-III\") # caches data from NIST but does not assign to a variable\n\n# Oxygen I-III will still be plotted, each ionization state separately.\nlines_all_cached = nist.get_all_cached()\nfor species,lines in lines_all_cached.groupby([\"element\",\"sp_num\"]):\n    plt.plot(lines['obs_wl_air(nm)'], lines['intens'], label=f\"{species[0]} {species[1]}\", marker='x', ls='none')\nplt.legend()\n</code></pre>"},{"location":"#citing","title":"Citing","text":"<p>Be sure to cite the NIST ASD when using <code>ASDCache</code> in your work, since it is the source of the data.</p> <p><code>ASDCache</code> itself can be cited using the following DOI provided via Zenodo:</p> <p>See also this page for more information</p>"},{"location":"#license","title":"License","text":"<p>ASDCache is licensed under the MIT license.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>Initial development release.</p> <ul> <li>Support fetching and caching from the NIST ASD</li> <li>Cache-TTL defaults to 1 week for now</li> <li>Caching hash is computed on all query parameters by default (<code>strict</code>=True)<ul> <li>Can be cached on only elements, ionization and wavelength range, with <code>strict</code> = False</li> </ul> </li> <li>Enable retrieving all cached species/queries</li> <li>Give user the option to use <code>polars</code> instead of <code>pandas</code> as Dataframe backend if installed</li> <li>Start writing documentation</li> <li>Auto-generated code reference included</li> <li>Example usage using a jupyter notebook included</li> <li>Add citing information</li> <li>Add test using <code>pytest</code></li> <li>Also checks for consistentcy of results between <code>pandas</code> and <code>polars</code> backends.</li> <li>Set up CI/CD</li> <li>Documentation automatic generation and deploy of latest version</li> <li>Automated run of test suite</li> </ul>"},{"location":"citing/","title":"Citing and Acknowledging","text":"<p>When using <code>readASD</code> in your research or work in general, please make sure to cite the following works, using the appropriate citation format and conventions.</p> <p>First and foremost, cite the NIST Atomic Spectra Database that curates and publishes the relevant data.</p> <p>They have a recommended citation format on a dedicated page, with relevant version history information.</p> <p>Below is a summary of these, but be sure to update the version information if necessary.</p> NIST ASD citationRecommended formatBibTeX <p>Citation</p> <p>Kramida, A., Ralchenko, Yu., Reader, J. and NIST ASD Team (2024). NIST Atomic Spectra Database (version 5.12), [Online]. Available: https://physics.nist.gov/asd [Thu Dec 12 2024]. National Institute of Standards and Technology, Gaithersburg, MD. DOI: https://doi.org/10.18434/T4W30F</p> <p>Citation style</p> <p>Author(s)/editor(s) (Year). Title (edition), [Type of medium]. Available: URL [Access date].</p> <pre><code>@dataset{Kramida2024NISTASD,\n    doi = {10.18434/T4W30F},\n    url = {https://physics.nist.gov/asd},\n    author = {Kramida,  Alexander and Ralchenko,  Yuri and Reader, Joseph and {NIST ASD Team}},\n    langid = {en},\n    title = {{NIST} {A}tomic {S}pectra {D}atabase},\n    titleaddon = {{NIST} {S}tandard {R}eference {D}atabase 78},\n    organization = {National Institute of Standards and Technology},\n    note = {Online},\n    version = {5.12},\n    year = {2024},\n    month = nov\n}\n</code></pre> <p>In addition, you can cite <code>readASD</code> itself, using the Zenodo DOI identifier:</p> Cite <code>readASD</code>BibTeX <p>Citation</p> <p>Salden A. (2024)...</p> <pre><code>@software{Salden2024readASD,\n    doi = {10.5281/ZENODO.},\n    url = {https://github.com/AntoineTUE/readasd},\n    author = {Salden, Antoine},\n    title = {readASD: retrieve data from the NIST ASD, using caching},\n    publisher = {Zenodo},\n    version = {},\n    year = {2024},\n}\n</code></pre>"},{"location":"examples/","title":"Examples of using ASDCache","text":"In\u00a0[1]: Copied! <pre>from ASDCache import SpectraCache\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nnist = SpectraCache(use_polars_backend=False)\n</pre> from ASDCache import SpectraCache import matplotlib.pyplot as plt import pandas as pd import numpy as np  nist = SpectraCache(use_polars_backend=False) <p>Let's perform a lookup of the lines for several different species.</p> <p>Each <code>fetch</code> will return a <code>DataFrame</code> containing the data contained in the NIST ASD table.</p> <p>Notice that the first time you run these commands it may take several seconds to retrieve the requested data, but subsequent repetitions are fast.</p> In\u00a0[2]: Copied! <pre>lines_H_I = nist.fetch(\"H I\", wl_range=(170, 1000))  # This is the range used by default\nlines_O_I_III = nist.fetch(\"O I-III\")\nlines_Ar_I_II = nist.fetch(\"Ar I-II\")\n</pre> lines_H_I = nist.fetch(\"H I\", wl_range=(170, 1000))  # This is the range used by default lines_O_I_III = nist.fetch(\"O I-III\") lines_Ar_I_II = nist.fetch(\"Ar I-II\") In\u00a0[3]: Copied! <pre>%timeit lines_H_I = nist.fetch(\"H I\")\n</pre> %timeit lines_H_I = nist.fetch(\"H I\") <pre>10.3 ms \u00b1 229 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</pre> <p>Let's check out what is contained in the retrieved Dataframe.</p> <p>If we inspect the head of the table, we can see numerous columns that contain relevant information for each line, such as term symbols, energy levels, wavelengths, element, ionization state and bibliographic reference code.</p> <p>The names of these columns are consistent with those retrieved from the NIST ASD, when using the <code>Tab-separated</code> output option.</p> In\u00a0[4]: Copied! <pre>lines_H_I.head()\n</pre> lines_H_I.head() Out[4]: element sp_num obs_wl_vac(nm) unc_obs_wl obs_wl_air(nm) ritz_wl_vac(nm) unc_ritz_wl ritz_wl_air(nm) wn(cm-1) intens ... term_i J_i conf_k term_k J_k g_i g_k Type tp_ref line_ref 0 H 1 NaN NaN NaN 365.61647 0.00013 365.512338 27351.065 NaN ... NaN NaN 40 NaN NaN 8.0 3200.0 E1 T8637 NaN 1 H 1 NaN NaN NaN 365.66407 0.00013 365.559925 27347.505 NaN ... NaN NaN 39 NaN NaN 8.0 3042.0 E1 T8637 NaN 2 H 1 NaN NaN NaN 365.71549 0.00013 365.611332 27343.660 NaN ... NaN NaN 38 NaN NaN 8.0 2888.0 E1 T8637 NaN 3 H 1 365.769 0.003 365.664828 365.77116 0.00019 365.666988 27339.650 700.0 ... NaN NaN 37 NaN NaN 8.0 2738.0 E1 T8637 L7400c29 4 H 1 365.829 0.003 365.724813 365.83154 0.00019 365.727352 27335.160 700.0 ... NaN NaN 36 NaN NaN 8.0 2592.0 E1 T8637 L7400c29 <p>5 rows \u00d7 28 columns</p> In\u00a0[5]: Copied! <pre>for lines_set in [lines_H_I, lines_O_I_III, lines_Ar_I_II]:\n    for lower, lines in lines_set[lines_set.intens.notna()].groupby([\"element\", \"sp_num\"]):\n        plt.plot(lines[\"obs_wl_vac(nm)\"], lines[\"Aki(s^-1)\"], marker=\"x\", ls=\"none\", label=f\"{lower[0]} {lower[1]}\")\nplt.legend()\nplt.xlabel(r\"$\\lambda$ (nm)\")\nplt.ylabel(r\"A$_{ki}$ $(\\mathrm{s}^{-1})$\")\n</pre> for lines_set in [lines_H_I, lines_O_I_III, lines_Ar_I_II]:     for lower, lines in lines_set[lines_set.intens.notna()].groupby([\"element\", \"sp_num\"]):         plt.plot(lines[\"obs_wl_vac(nm)\"], lines[\"Aki(s^-1)\"], marker=\"x\", ls=\"none\", label=f\"{lower[0]} {lower[1]}\") plt.legend() plt.xlabel(r\"$\\lambda$ (nm)\") plt.ylabel(r\"A$_{ki}$ $(\\mathrm{s}^{-1})$\") Out[5]: <pre>Text(0, 0.5, 'A$_{ki}$ $(\\\\mathrm{s}^{-1})$')</pre> In\u00a0[6]: Copied! <pre>eV_in_wn = 8065.544  # express energy in eV\n\nfig, ax = plt.subplots(1, 2, sharex=True, sharey=False, gridspec_kw={\"wspace\": 0.05})\n\nfor i, Te in enumerate([2, 6]):\n    for lines_set in [lines_H_I, lines_O_I_III, lines_Ar_I_II]:\n        for lower, lines in lines_set[\n            (lines_set.sp_num &lt; 3) &amp; (lines_set.Type == \"E1\") &amp; (lines_set.intens.notna())\n        ].groupby([\"element\", \"sp_num\"]):\n            ax[i].plot(\n                lines[\"obs_wl_vac(nm)\"],\n                lines[\"Aki(s^-1)\"] * lines.g_k * np.exp(-lines[\"Ek(cm-1)\"] / eV_in_wn / Te),\n                marker=\"x\",\n                ls=\"none\",\n                label=f\"{lower[0]} {lower[1]}\",\n            )\n    ax[i].set_title(f\"$T_e={Te:.1f}$ eV\", ha=\"center\")\n\nax[0].legend()\nfor a in ax:\n    a.set_xlabel(r\"$\\lambda$ (nm)\")\nplt.xlim(300, 900)\nax[0].set_ylabel(r\"$\\phi_{photon}$ (s$^{-1}$m$^{-3}$)\")\n\nax[1].tick_params(labelleft=False, labelright=True)\nax[1].yaxis.set_label_position(\"right\")\n</pre> eV_in_wn = 8065.544  # express energy in eV  fig, ax = plt.subplots(1, 2, sharex=True, sharey=False, gridspec_kw={\"wspace\": 0.05})  for i, Te in enumerate([2, 6]):     for lines_set in [lines_H_I, lines_O_I_III, lines_Ar_I_II]:         for lower, lines in lines_set[             (lines_set.sp_num &lt; 3) &amp; (lines_set.Type == \"E1\") &amp; (lines_set.intens.notna())         ].groupby([\"element\", \"sp_num\"]):             ax[i].plot(                 lines[\"obs_wl_vac(nm)\"],                 lines[\"Aki(s^-1)\"] * lines.g_k * np.exp(-lines[\"Ek(cm-1)\"] / eV_in_wn / Te),                 marker=\"x\",                 ls=\"none\",                 label=f\"{lower[0]} {lower[1]}\",             )     ax[i].set_title(f\"$T_e={Te:.1f}$ eV\", ha=\"center\")  ax[0].legend() for a in ax:     a.set_xlabel(r\"$\\lambda$ (nm)\") plt.xlim(300, 900) ax[0].set_ylabel(r\"$\\phi_{photon}$ (s$^{-1}$m$^{-3}$)\")  ax[1].tick_params(labelleft=False, labelright=True) ax[1].yaxis.set_label_position(\"right\") In\u00a0[7]: Copied! <pre>import Moose\n</pre> import Moose In\u00a0[8]: Copied! <pre>all_lines = pd.concat([lines_H_I, lines_O_I_III, lines_Ar_I_II]).sort_values(\"obs_wl_air(nm)\")\nall_allowed_lines = all_lines[(all_lines.Type == \"E1\") &amp; (all_lines.intens.notna())]\n\nfig, ax = plt.subplots(4, 1, sharex=True, sharey=True, gridspec_kw={\"hspace\": 0.06})\nfor i, Te in enumerate([0.5, 2, 4, 8]):\n    spec = Moose.apply_voigt(\n        Moose.equidistant_mesh(\n            pd.DataFrame(\n                np.array(\n                    [\n                        all_allowed_lines[\"obs_wl_air(nm)\"],\n                        all_allowed_lines[\"Aki(s^-1)\"]\n                        * all_allowed_lines[\"g_k\"]\n                        * np.exp(-all_allowed_lines[\"Ek(cm-1)\"] / eV_in_wn / Te),\n                    ]\n                ).T\n            )\n            .dropna()\n            .to_numpy()\n        ),\n        0.3,\n        0.3,\n        False,\n    )\n    ax[i].plot(\n        spec[:, 0], (spec[:, 1] - spec[:, 1].min()) / (spec[:, 1].max() - spec[:, 1].min()), label=f\"$T_e=${Te:.1f} eV\"\n    )\n    ax[i].legend(loc=\"upper left\")\nplt.xlabel(r\"$\\lambda$ (nm)\")\n\nfor a in ax:\n    a.set_ylabel(\"$I$ (a.u.)\")\n</pre> all_lines = pd.concat([lines_H_I, lines_O_I_III, lines_Ar_I_II]).sort_values(\"obs_wl_air(nm)\") all_allowed_lines = all_lines[(all_lines.Type == \"E1\") &amp; (all_lines.intens.notna())]  fig, ax = plt.subplots(4, 1, sharex=True, sharey=True, gridspec_kw={\"hspace\": 0.06}) for i, Te in enumerate([0.5, 2, 4, 8]):     spec = Moose.apply_voigt(         Moose.equidistant_mesh(             pd.DataFrame(                 np.array(                     [                         all_allowed_lines[\"obs_wl_air(nm)\"],                         all_allowed_lines[\"Aki(s^-1)\"]                         * all_allowed_lines[\"g_k\"]                         * np.exp(-all_allowed_lines[\"Ek(cm-1)\"] / eV_in_wn / Te),                     ]                 ).T             )             .dropna()             .to_numpy()         ),         0.3,         0.3,         False,     )     ax[i].plot(         spec[:, 0], (spec[:, 1] - spec[:, 1].min()) / (spec[:, 1].max() - spec[:, 1].min()), label=f\"$T_e=${Te:.1f} eV\"     )     ax[i].legend(loc=\"upper left\") plt.xlabel(r\"$\\lambda$ (nm)\")  for a in ax:     a.set_ylabel(\"$I$ (a.u.)\") <p>Alternatively, we can also compare the spectra for different $T_e$ for each species, to develop our understanding of which lines could contribute to an experimentally observed spectrum.</p> <p>To that effect, let's once more take all allowed dipole transitions and group them by their (<code>element</code>, <code>sp_num</code>).</p> <p>We repeat the same calculation as above, but now separately for each species.</p> <p>We thus skip any assumptions on their respective population fractions and only consider the distribution across states for the given species at a given $T_e$.</p> <p>Note that once more, we normalize the spectra to [0,1] for clarity.</p> In\u00a0[9]: Copied! <pre>n_species = all_allowed_lines.groupby([\"element\", \"sp_num\"]).ngroups\nfig, ax = plt.subplots(\n    n_species, 1, sharey=True, sharex=True, gridspec_kw={\"wspace\": 0.03, \"hspace\": 0.05}, figsize=(8, 7)\n)\n\nfor i, (specie, lines) in enumerate(all_allowed_lines.groupby([\"element\", \"sp_num\"])):\n    for Te in [5, 1]:\n        spec = Moose.apply_voigt(\n            Moose.equidistant_mesh(\n                pd.DataFrame(\n                    np.array(\n                        [\n                            lines[\"obs_wl_air(nm)\"],\n                            lines[\"Aki(s^-1)\"] * lines[\"g_k\"] * np.exp(-lines[\"Ek(cm-1)\"] / eV_in_wn / Te),\n                        ]\n                    ).T\n                )\n                .dropna()\n                .to_numpy()\n            ),\n            0.3,\n            0.3,\n            False,\n        )\n        ax[i].plot(\n            spec[:, 0],\n            (spec[:, 1] - spec[:, 1].min()) / (spec[:, 1].max() - spec[:, 1].min()),\n            label=f\"{specie[0]} {specie[1]}: $T_e=${Te:.1f} eV\",\n        )\n    ax[i].legend()\n\nfor a in ax:\n    a.set_xlabel(r\"$\\lambda$ (nm)\")\n</pre> n_species = all_allowed_lines.groupby([\"element\", \"sp_num\"]).ngroups fig, ax = plt.subplots(     n_species, 1, sharey=True, sharex=True, gridspec_kw={\"wspace\": 0.03, \"hspace\": 0.05}, figsize=(8, 7) )  for i, (specie, lines) in enumerate(all_allowed_lines.groupby([\"element\", \"sp_num\"])):     for Te in [5, 1]:         spec = Moose.apply_voigt(             Moose.equidistant_mesh(                 pd.DataFrame(                     np.array(                         [                             lines[\"obs_wl_air(nm)\"],                             lines[\"Aki(s^-1)\"] * lines[\"g_k\"] * np.exp(-lines[\"Ek(cm-1)\"] / eV_in_wn / Te),                         ]                     ).T                 )                 .dropna()                 .to_numpy()             ),             0.3,             0.3,             False,         )         ax[i].plot(             spec[:, 0],             (spec[:, 1] - spec[:, 1].min()) / (spec[:, 1].max() - spec[:, 1].min()),             label=f\"{specie[0]} {specie[1]}: $T_e=${Te:.1f} eV\",         )     ax[i].legend()  for a in ax:     a.set_xlabel(r\"$\\lambda$ (nm)\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/#examples-of-using-asdcache","title":"Examples of using ASDCache\u00b6","text":""},{"location":"examples/#using-spectracache-to-cache-data-with-asdcache","title":"Using <code>SpectraCache</code> to cache data with ASDCache\u00b6","text":"<p><code>ASDCache</code> contains the <code>SpectraCache</code> class, which is the entrypoint to the cache and the ASD.</p> <p>All instances of <code>SpectraCache</code> share the same <code>SQLite</code> cache file on the local system, located in the system's user cache directory.</p> <p>The <code>SpectraCache</code> support either using <code>pandas</code> or <code>polars</code> as the dataframe backend for retrieved data.</p>"},{"location":"examples/#plotting-line-positions","title":"Plotting line positions\u00b6","text":"<p>We can use the retrieved data to visualize line positions, based on e.g. their Einstein coefficient, to help us identify lines in a spectrum.</p> <p>To make sure we plot the positions for each (<code>element</code>, <code>sp_num</code>) pair seperately (so that we can identify them), we make use of a <code>groupby</code> operation on the retrieved Dataframes.</p> <p>The <code>sp_num</code> column contains the ionization degree of the element, where 1 signifies the non-ionized atom.</p> <p>In addition, we filter the data down by only plotting lines that have a value in the <code>intens</code> column larger than 0, which corresponds to the <code>Rel. Int.</code> column in the online NIST ASD HTML table.</p> <p>Note: by convention <code>ASDCache</code> uses the column names of the tab-separated ASD output, not the column labels of the human-readable HTML formatted table.</p> <p>The ionization states are contained in the <code>sp_num</code> column, where the value <code>1</code> corresponds to the ground state.</p> <p>The NIST ASD tends to use roman numerals when querying a specific state (i.e. <code>H I</code>), but returns integers when retrieving data for different states (i.e. <code>O I-III</code>).</p> <p><code>ASDCache</code> always uses integers to represent this data, such that we can filter this data based on comparisons like <code>&gt;</code> or <code>&lt;=</code>.</p> <p>Using a numeric data type also brings performance benefits, though these are likely insignificant.</p>"},{"location":"examples/#compute-a-simple-stick-spectrum","title":"Compute a simple stick spectrum\u00b6","text":"<p>Instead of simply plotting data retrieved from the ASD directly, we can also use the retrieved information to drive some calculations.</p> <p>We can calculate spectra (or rather line intensities) at different electron temperature $T_e$.</p> <p>In principle, you need to account for the abundance of each element, and then account for the respective ionization energies in calculating the ionization partition sum, when assuming a local thermodynamic equilibrium (LTE).</p> <p>For sake of simplicity, this example will plot several different atoms/ions while ignoring different populations and statistical weight for each species.</p> <p>In other words: we skip calculating a distribution function between the different species and only use the electron temperature $T_e$ to calculate the population distribution of the different states within each species (a particular atom/ion), to arrive at a photon emission rate per volume for each emitting upper state $k$:</p> <p>$\\phi_{photon}\\propto g_k\\cdot A_{ki}\\cdot \\exp(-E_k/T_e)$.</p> <p>We thus implicitly assume a Maxwellian distribution for the electron energy distribution function (EEDF), parameterized by $T_e$.</p> <p>Notice in the plot below that $\\mathrm{Ar}^+ $ and $\\mathrm{O}^+ $ become more prominent at higher $T_e$, as their strongly emitting higher energy states become more populated (see above).</p> <p>This is separate from the change in their respective population fraction (w.r.t. the ground state) for different $T_e$ that you would expect for an LTE plasma (since we ignore this effect here).</p> <p>Also notice that we only select electric dipole-allowed (E1) transitions, by filtering using the criterium <code>lines_set.Type==\"E1\"</code>.</p>"},{"location":"examples/#simulate-the-spectrum","title":"Simulate the spectrum\u00b6","text":"<p>From the generated stick spectrum it becomes fairly trivial to simulate a spectrum (though we use crude assumptions and filtering in this example).</p> <p>Here we rely on Moose to transform the stick spectrum into a uniformally broadened spectrum, and plot spectra for different $T_e$, using the assumptions above.</p> <p>First we use <code>Moose.equidistant_mesh</code> to bin the contributions of all lines on an equidistant wavelength axis.</p> <p>Following this, a spectrum subject to voigt broadening is calculated with <code>Moose.apply_voigt</code>, with both Gaussian and Lorentzian broadening equal to 0.3 nm.</p> <p>Once more, bear in mind that in practice you should account for the different population fractions of each species and that the electron energy distribution function may not be represented by a Maxwellian.</p> <p>The results plotted below are normalized on the interval [0,1].</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2024, Antoine Salden</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"schema/","title":"Data schema overview","text":"<p>Info</p> <p>The schema of the data used in <code>ASDCache</code> in principle reflects that of the NIST ASD Line Table, using the tab-separated format. You can find the relevant information on the included data on this page of the NIST ASD documentation.</p> Column name Data type Description Note <code>element</code> <code>str</code> atomic element <code>sp_num</code> <code>int</code> ionization degree, starting with 1 for the unionized atom Only integers, not roman numerals <code>obs_wl_vac(nm)</code> <code>float</code> Observed vacuum wavelength <code>unc_obs_wl</code> <code>float</code> Uncertainty in observed vacuum wavelength <code>obs_wl_air(nm)</code> <code>float</code> Observed wavelength in air Calculated from <code>obs_wl_vac(nm)</code>, not retrieved from ASD <code>ritz_wl_vac(nm)</code> <code>float</code> Ritz wavelength in vacuum <code>unc_ritz_wl</code> <code>float</code> Uncertainty in Ritz wavelength <code>ritz_wl_air(nm)</code> <code>float</code> Ritz wavelength in air Calculated from <code>ritz_wl_vac(nm)</code>, not retrieved from ASD <code>wn(cm-1)</code> <code>float</code> Observed wavenumbers <code>intens</code> <code>float</code> Guideline for strenght of a line in an emission spectrum Also known as 'Rel. Intens.' in the HTML table. Does not include any of the footnotes available in the ASD. <code>Aki(s^-1)</code> <code>float</code> Einstein A coefficient of transition <code>fik</code> <code>float</code> Absorption oscillator strength <code>S(a.u.)</code> <code>float</code> Line strenght <code>log_gf</code> <code>float</code> \\log_{10}\\ g_{i}f_{ik} <code>Acc</code> <code>str</code> Estimated accuracy of transition strength <code>Ei(cm-1)</code> <code>float</code> Lower state energy <code>Ek(cm-1)</code> <code>float</code> Upper state energy <code>conf_i</code> <code>str</code> Lower state configuration <code>term_i</code> <code>str</code> Lower state term symbol <code>J_i</code> <code>str</code> Lower state total electronic angular momentum <code>conf_k</code> <code>str</code> Upper state configuration <code>term_k</code> <code>str</code> Upper state term symbol <code>J_k</code> <code>str</code> Upper state total electronic angular momentum <code>g_i</code> <code>float</code> Lower Land\u00e9 g factor <code>g_k</code> <code>float</code> Upper Land\u00e9 g factor <code>Type</code> <code>str</code> The type of transition Allowed electric-dipole transitions are explicitly labeled as <code>E1</code> <code>tp_ref</code> <code>str</code> Atomic Transition Probability Bibliographic Database Reference <code>line_ref</code> <code>str</code> Energy Levels and Wavelengths Bibliographic Reference"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ASDCache<ul> <li>ASDCache</li> </ul> </li> </ul>"},{"location":"reference/ASDCache/","title":"Reference","text":""},{"location":"reference/ASDCache/#ASDCache","title":"ASDCache","text":"<p>ASDCache is a module to retrieve data from the NIST Atomic Spectra Database that uses caching for fast local access.</p> <p>To make the most use out of the cache, <code>ASDCache</code> is opinionated in the information it retrieves from the ASD; it always requests the same schema of information and locally computes additional fields.</p> <p>The <code>SpectraCache</code> class acts as the entrypoint to retrieve this data.</p> <p>Modules:</p> Name Description <code>ASDCache</code> <p><code>ASDcache</code> is a module to fetch data from the  NIST Atomic Spectra Database (ASD), utlizing caching for fast responses.</p> <p>Classes:</p> Name Description <code>SpectraCache</code> <p>A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.</p>"},{"location":"reference/ASDCache/#ASDCache.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['SpectraCache']\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache","title":"SpectraCache","text":"<p>A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.</p> <p>The <code>ASDCache</code> instance acts as an access point to the cache, which stores responses on the local system in a SQLite database.</p> <p>Data retrieval from cache is much faster (order milliseconds) than fetching from the internet (order seconds), and avoids wastefull requests to the server.</p> <p>Cache time-to-live is one week by default.</p> <p>Since the NIST ASD is usually updated less frequently than that, this is a compromise between having the latest data, and overall fast performance.</p> <p>Note that the same cache is shared across different class-instances, thread-safety is not guaranteed.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize an instance that handles cached data lookup of the NIST ASD.</p> <code>create_dataframe</code> <p>Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.</p> <code>fetch</code> <p>Fetch information on a species from the ASD, first checking the cache.</p> <code>get_all_cached</code> <p>Retrieve all cached data into a single dataframe.</p> <code>list_cached_species</code> <p>List all species in the cache, based on the string of the original query URL.</p> <code>roman_to_int</code> <p>Transform Roman numerals to integers.</p> <code>wn_to_n_refractive</code> <p>Calculate the refractive index n in air for a transition, using the 5-term Sellmeier formula used by NIST.</p> <p>Attributes:</p> Name Type Description <code>cache_expiry</code> <code>column_order</code> <p>Fixed order of columns for consistent schema of data.</p> <code>known_species</code> <code>nist_url</code> <code>query_params</code> <p>Request parameters used by the NIST ASD form.</p> <code>session</code> <code>species_expr</code> <code>strict_matching</code> <code>use_polars</code> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>class SpectraCache:\n    \"\"\"A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.\n\n    The `ASDCache` instance acts as an access point to the cache, which stores responses on the local system in a SQLite database.\n\n    Data retrieval from cache is much faster (order milliseconds) than fetching from the internet (order seconds), and avoids wastefull requests to the server.\n\n    Cache time-to-live is one week by default.\n\n    Since the NIST ASD is usually updated less frequently than that, this is a compromise between having the latest data, and overall fast performance.\n\n    Note that the same cache is shared across different class-instances, thread-safety is not guaranteed.\n    \"\"\"\n\n    nist_url = \"https://physics.nist.gov/cgi-bin/ASD/lines1.pl\"\n    species_expr = re.compile(r\"spectra=([\\w\\+\\-\\%3]+)&amp;\")\n    query_params = {\n        \"unit\": 1,\n        \"de\": 0,\n        \"plot_out\": 0,\n        \"I_scale_type\": 1,\n        \"format\": 3,\n        \"line_out\": 0,\n        \"remove_js\": \"on\",\n        \"no_spaces\": \"on\",\n        \"en_unit\": 0,\n        \"output\": 0,\n        \"bibrefs\": 1,\n        \"show_obs_wl\": 1,\n        \"show_calc_wl\": 1,\n        \"show_wn\": 1,\n        \"unc_out\": 1,\n        \"order_out\": 0,\n        \"show_av\": 3,  # 3: wavelength in vac, 2: wavelength in air\n        \"tsb_value\": 0,\n        \"A_out\": 0,\n        \"S_out\": \"on\",\n        \"f_out\": \"on\",\n        \"loggf_out\": \"on\",\n        \"intens_out\": \"on\",\n        \"conf_out\": \"on\",\n        \"term_out\": \"on\",\n        \"enrg_out\": \"on\",\n        \"J_out\": \"on\",\n        \"g_out\": \"on\",\n        \"diag_out\": \"on\",\n        \"allowed_out\": 1,\n        \"forbid_out\": 1,\n        \"submit\": \"Retrieve Data\",\n    }\n    \"\"\"Request parameters used by the NIST ASD form.\"\"\"\n    column_order = [\n        \"element\",\n        \"sp_num\",\n        \"obs_wl_vac(nm)\",\n        \"unc_obs_wl\",\n        \"obs_wl_air(nm)\",\n        \"ritz_wl_vac(nm)\",\n        \"unc_ritz_wl\",\n        \"ritz_wl_air(nm)\",\n        \"wn(cm-1)\",\n        \"intens\",\n        \"Aki(s^-1)\",\n        \"fik\",\n        \"S(a.u.)\",\n        \"log_gf\",\n        \"Acc\",\n        \"Ei(cm-1)\",\n        \"Ek(cm-1)\",\n        \"conf_i\",\n        \"term_i\",\n        \"J_i\",\n        \"conf_k\",\n        \"term_k\",\n        \"J_k\",\n        \"g_i\",\n        \"g_k\",\n        \"Type\",\n        \"tp_ref\",\n        \"line_ref\",\n    ]\n    \"\"\"Fixed order of columns for consistent schema of data.\"\"\"\n\n    def __init__(self, use_polars_backend=False, cache_expiry=timedelta(weeks=1), strict_matching=True):\n        \"\"\"Initialize an instance that handles cached data lookup of the NIST ASD.\"\"\"\n        self.strict_matching = strict_matching\n        self.cache_expiry = cache_expiry\n        self.session = CachedSession(\n            \"NIST_ASD_cache\",\n            use_cache_dir=True,\n            expire_after=cache_expiry,\n            stale_if_error=True,\n            filter_fn=self._check_response_success,\n            ignored_parameters=list(self.query_params.keys()) if self.strict_matching is False else None,\n        )\n        if (use_polars_backend) &amp; (not POLARS_AVAILABLE):\n            warnings.warn(\"Cannot find `polars` as a backend, falling back to `pandas`\", stacklevel=2)\n            self.use_polars = False\n        else:\n            self.use_polars = use_polars_backend\n\n        self.known_species = self.list_cached_species()\n\n    @staticmethod\n    def _check_response_success(response: \"CachedResponse\") -&gt; bool:\n        \"\"\"Validate that data has been fetched succesfully.\n\n        If this check fails, the cache should not update with this response, even when marked as stale.\n        \"\"\"\n        return (response.status_code == 200) &amp; (b\"Error Message\" not in response.content)\n\n    def list_cached_species(self) -&gt; list[str]:\n        \"\"\"List all species in the cache, based on the string of the original query URL.\"\"\"\n        return [\n            elem.replace(\"+\", \" \")\n            for u in self.session.cache.urls()\n            for elem in self.species_expr.search(u).group(1).split(\"%3B\")\n        ]\n\n    def fetch(self, species, wl_range=(170, 1000), **kwargs) -&gt; \"pd.DataFrame|pl.DataFrame|CachedResponse\":\n        \"\"\"Fetch information on a species from the ASD, first checking the cache.\n\n        This supports loading multiple species in one go by using the same notation as the NIST ASD page.\n\n        Note however that cache keys are computed for unique options for `species` and `wl_range`.\n\n        This means that you won't get caching benefits by using different queries.\n\n        In other words: the cache cannot deduplicate queries such as `ASD.fetch('H', (200,1000))` followed by `ASD.fetch('H I', (650,660))`.\n\n        Both these operations will fetch data online and be stored as separate cache entries.\n        \"\"\"\n        query_params = {\n            \"spectra\": species,\n            \"output_type\": 0,\n            \"low_w\": min(wl_range),\n            \"upp_w\": max(wl_range),\n            **self.query_params,\n        }\n        response = self.session.get(self.nist_url, params=query_params)\n\n        if response.status_code == 200:\n            return self.create_dataframe(response)\n        else:\n            print(f\"Error: Received status code {response.status_code}\")\n            print(response.url)\n            return response\n\n    def create_dataframe(self, response) -&gt; \"pd.DataFrame|pl.DataFrame\":\n        \"\"\"Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.\"\"\"\n        if self.use_polars:\n            return self._from_polars(response)\n        return self._from_pandas(response)\n\n    @classmethod\n    def _from_pandas(cls, response: \"CachedResponse\") -&gt; \"pd.DataFrame\":\n        r\"\"\"Transform a (cached) NIST ASD response into a pandas DataFrame.\n\n        Calculates the air equivalent wavelength from the vacuum wavelength using the same Sellmeier equation as the NIST ASD.\n\n        Note that this conversion is only performed for lines with $200 nm &lt; \\lambda &lt; 2000 nm$, like the ASD.\n\n        For lines outside of this range, the conversion falls back to their vacuum wavelength.\n        \"\"\"\n        schema = {\n            \"obs_wl_vac(nm)\": str,\n            \"ritz_wl_vac(nm)\": str,\n            \"wn(cm-1)\": float,\n            \"intens\": str,\n            \"Aki(s^-1)\": float,\n            \"fik\": float,\n            \"S(a.u.)\": float,\n            \"log_gf\": float,\n            \"Acc\": str,\n            \"Ei(cm-1)\": str,\n            \"Ek(cm-1)\": str,\n            \"conf_i\": str,\n            \"conf_k\": str,\n            \"term_i\": str,\n            \"term_k\": str,\n            \"g_i\": float,\n            \"g_k\": float,\n            \"J_i\": str,\n            \"J_k\": str,\n            \"\": str,\n        }\n        df = pd.read_csv(StringIO(response.text), sep=\"\\t\", dtype=schema)\n        for col in [\"obs_wl_vac(nm)\", \"ritz_wl_vac(nm)\", \"intens\", \"Ei(cm-1)\", \"Ek(cm-1)\"]:\n            df[col] = df.loc[:, col].str.extract(r\"([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\").astype(float)\n        df[\"Type\"] = df.loc[:, \"Type\"].astype(str).replace(\"nan\", \"E1\")\n        df[\"tp_ref\"] = df.loc[:, \"tp_ref\"].fillna(\"\")\n        df[\"obs_wl_air(nm)\"] = df[\"obs_wl_vac(nm)\"]\n        df[\"obs_wl_air(nm)\"] = df[df[\"wn(cm-1)\"].between(5000, 50000)][\"obs_wl_air(nm)\"] / cls.wn_to_n_refractive(\n            df[df[\"wn(cm-1)\"].between(5000, 50000)][\"wn(cm-1)\"]\n        )\n        df[\"ritz_wl_air(nm)\"] = df[\"ritz_wl_vac(nm)\"]\n        df[\"ritz_wl_air(nm)\"] = df[df[\"wn(cm-1)\"].between(5000, 50000)][\"ritz_wl_air(nm)\"] / cls.wn_to_n_refractive(\n            df[df[\"wn(cm-1)\"].between(5000, 50000)][\"wn(cm-1)\"]\n        )\n        df = df.drop([c for c in df.columns if \"Unnamed\" in c], axis=1).reset_index(drop=True)\n        if \"element\" not in df.columns:\n            expr = re.compile(r\"spectra=([\\w]+)\\+?([IVX]+)?\")\n            element, numeral = expr.search(response.url).groups()\n            df[\"element\"] = element\n            df[\"sp_num\"] = numeral\n            # cast roman numerals to int for consistency with queries with multiple ionization states, e.g. Ar I vs Ar I-II\n            df[\"sp_num\"] = df[\"sp_num\"].map(cls.roman_to_int)\n        df = (\n            df.assign(unc_obs_wl=df[\"unc_obs_wl\"].astype(float), unc_ritz_wl=df[\"unc_ritz_wl\"].astype(float))\n            if \"unc_obs_wl\" in df.columns\n            else df.assign(unc_obs_wl=np.nan, unc_ritz_wl=np.nan)\n        )\n        return df.loc[:, cls.column_order]\n\n    @classmethod\n    def _from_polars(cls, response: \"CachedResponse\") -&gt; \"pl.DataFrame\":\n        r\"\"\"Transform a (cached) NIST ASD response into a polars DataFrame.\n\n        Calculates the air equivalent wavelength from the vacuum wavelength using the same Sellmeier equation as the NIST ASD.\n\n        Note that this conversion is only performed for lines with $200 nm &lt; \\lambda &lt; 2000 nm$, like the ASD.\n\n        For lines outside of this range, the conversion falls back to their vacuum wavelength.\n        \"\"\"\n        schema = {\n            \"obs_wl_vac(nm)\": pl.String,\n            \"ritz_wl_vac(nm)\": pl.String,\n            \"wn(cm-1)\": pl.Float64,\n            \"intens\": pl.String,\n            \"Aki(s^-1)\": pl.Float64,\n            \"fik\": pl.Float64,\n            \"S(a.u.)\": pl.Float64,\n            \"log_gf\": pl.Float64,\n            \"Acc\": pl.String,\n            \"Ei(cm-1)\": pl.String,\n            \"Ek(cm-1)\": pl.String,\n            \"conf_i\": pl.String,\n            \"conf_k\": pl.String,\n            \"term_i\": pl.String,\n            \"term_k\": pl.String,\n            \"g_i\": pl.Float64,\n            \"g_k\": pl.Float64,\n            \"J_i\": pl.String,\n            \"J_k\": pl.String,\n            \"\": pl.String,\n        }\n        # annotation_chars_to_strip = \"(?i)()[]?*w,bGhilmprsq:+xzgacHd \"\n        df = (\n            pl.read_csv(\n                StringIO(response.text),\n                separator=\"\\t\",\n                schema_overrides=schema,\n                null_values=\"\",\n            )\n            .with_columns(\n                pl.col(\"obs_wl_vac(nm)\", \"Ei(cm-1)\", \"Ek(cm-1)\", \"intens\")\n                # .str.strip_chars(annotation_chars_to_strip).str.replace(\"&amp;dagger;\", \"\", literal=True)\n                .str.extract(r\"([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\")\n                # .str.extract(r\"([+-]?\\d*\\.?\\d+e[+-]?\\d+)\")\n                .replace(\"\", None)\n                .cast(pl.Float64),\n                pl.col(\"ritz_wl_vac(nm)\").str.strip_chars('\"+*').replace(\"\", None).cast(pl.Float64),\n                pl.col(\"S(a.u.)\").cast(pl.Float64),\n                pl.col(\"Type\").replace(None, \"E1\"),\n                pl.col(\"tp_ref\").replace(None, \"\"),\n            )\n            .drop([\"\"])\n        ).with_columns(\n            pl.when(pl.col(\"wn(cm-1)\").is_between(5000, 50000))\n            .then(\n                pl.col(\"obs_wl_vac(nm)\").cast(pl.Float64)\n                / pl.col(\"wn(cm-1)\").map_elements(cls.wn_to_n_refractive, return_dtype=pl.Float64)\n            )\n            .otherwise(pl.col(\"obs_wl_vac(nm)\"))\n            .cast(pl.Float64)\n            .alias(\"obs_wl_air(nm)\"),\n            pl.when(pl.col(\"wn(cm-1)\").is_between(5000, 50000))\n            .then(\n                pl.col(\"ritz_wl_vac(nm)\").cast(pl.Float64)\n                / pl.col(\"wn(cm-1)\").map_elements(cls.wn_to_n_refractive, return_dtype=pl.Float64)\n            )\n            .otherwise(pl.col(\"ritz_wl_vac(nm)\"))\n            .cast(pl.Float64)\n            .alias(\"ritz_wl_air(nm)\"),\n        )\n        if \"element\" not in df.columns:\n            expr = re.compile(r\"spectra=([\\w]+)\\+?([IVX]+)?\")\n            element, numeral = expr.search(response.url).groups()\n            # cast roman numerals to int for consistency with queries with multiple ionization states, e.g. Ar I vs Ar I-II\n            df = df.with_columns(\n                pl.lit(element).alias(\"element\"),\n                pl.lit(\"I\" if numeral is None else numeral)\n                .cast(pl.String)\n                .alias(\"sp_num\")\n                .map_elements(cls.roman_to_int, return_dtype=pl.Int64),\n            )\n        df = (\n            df.with_columns(pl.col(\"unc_obs_wl\").cast(pl.Float64), pl.col(\"unc_ritz_wl\").cast(pl.Float64))\n            if \"unc_obs_wl\" in df.columns\n            else df.with_columns(\n                pl.lit(None).cast(pl.Float64).alias(\"unc_obs_wl\"), pl.lit(None).cast(pl.Float64).alias(\"unc_ritz_wl\")\n            )\n        )\n\n        return df.select(*cls.column_order)\n\n    @staticmethod\n    def roman_to_int(roman: str) -&gt; int:\n        \"\"\"Transform Roman numerals to integers.\n\n        Does only support numerals including up to `L`.\n        \"\"\"\n        roman_numerals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50}\n        total = 0\n        previous = 0\n        for char in reversed(roman):\n            current_value = roman_numerals[char]\n            if current_value &lt; previous:\n                total -= current_value  # Subtract if the current value is less than the previous value\n            else:\n                total += current_value\n            previous = current_value\n        return total\n\n    @staticmethod\n    def wn_to_n_refractive(wavenumbers: float) -&gt; float:\n        r\"\"\"Calculate the refractive index $n$ in air for a transition, using the 5-term Sellmeier formula used by NIST.\n\n        The used Sellmeier formula is the one from E.R. Peck and K. Reeder [J. Opt. Soc. Am. 62, 958 (1972)](http://dx.doi.org/10.1364/JOSA.62.000958).\n\n        This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.\n\n        This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.\n\n        See also [the ASD documentation on the topic](https://physics.nist.gov/PhysRefData/ASD/Html/lineshelp.html#Conversion%20between%20air%20and%20vacuum%20wavelengths).\n\n        Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.\n        \"\"\"\n        sigma = wavenumbers * 1e-4  # um^-1\n        return 1 + 1e-8 * (8060.51 + 2480990 / (132.274 - sigma**2) + 17455.7 / (39.32957 - sigma**2))\n\n    def get_all_cached(self) -&gt; \"pd.DataFrame|pl.DataFrame\":\n        \"\"\"Retrieve all cached data into a single dataframe.\"\"\"\n        cached_frames = [self.create_dataframe(cached) for cached in self.session.cache.filter()]\n        if self.use_polars:\n            return pl.concat(cached_frames).unique()\n        return pd.concat(cached_frames).drop_duplicates().reset_index(drop=True)\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.cache_expiry","title":"cache_expiry  <code>instance-attribute</code>","text":"<pre><code>cache_expiry = cache_expiry\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.column_order","title":"column_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_order = [\n    \"element\",\n    \"sp_num\",\n    \"obs_wl_vac(nm)\",\n    \"unc_obs_wl\",\n    \"obs_wl_air(nm)\",\n    \"ritz_wl_vac(nm)\",\n    \"unc_ritz_wl\",\n    \"ritz_wl_air(nm)\",\n    \"wn(cm-1)\",\n    \"intens\",\n    \"Aki(s^-1)\",\n    \"fik\",\n    \"S(a.u.)\",\n    \"log_gf\",\n    \"Acc\",\n    \"Ei(cm-1)\",\n    \"Ek(cm-1)\",\n    \"conf_i\",\n    \"term_i\",\n    \"J_i\",\n    \"conf_k\",\n    \"term_k\",\n    \"J_k\",\n    \"g_i\",\n    \"g_k\",\n    \"Type\",\n    \"tp_ref\",\n    \"line_ref\",\n]\n</code></pre> <p>Fixed order of columns for consistent schema of data.</p>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.known_species","title":"known_species  <code>instance-attribute</code>","text":"<pre><code>known_species = list_cached_species()\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.nist_url","title":"nist_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nist_url = 'https://physics.nist.gov/cgi-bin/ASD/lines1.pl'\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.query_params","title":"query_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>query_params = {\n    \"unit\": 1,\n    \"de\": 0,\n    \"plot_out\": 0,\n    \"I_scale_type\": 1,\n    \"format\": 3,\n    \"line_out\": 0,\n    \"remove_js\": \"on\",\n    \"no_spaces\": \"on\",\n    \"en_unit\": 0,\n    \"output\": 0,\n    \"bibrefs\": 1,\n    \"show_obs_wl\": 1,\n    \"show_calc_wl\": 1,\n    \"show_wn\": 1,\n    \"unc_out\": 1,\n    \"order_out\": 0,\n    \"show_av\": 3,\n    \"tsb_value\": 0,\n    \"A_out\": 0,\n    \"S_out\": \"on\",\n    \"f_out\": \"on\",\n    \"loggf_out\": \"on\",\n    \"intens_out\": \"on\",\n    \"conf_out\": \"on\",\n    \"term_out\": \"on\",\n    \"enrg_out\": \"on\",\n    \"J_out\": \"on\",\n    \"g_out\": \"on\",\n    \"diag_out\": \"on\",\n    \"allowed_out\": 1,\n    \"forbid_out\": 1,\n    \"submit\": \"Retrieve Data\",\n}\n</code></pre> <p>Request parameters used by the NIST ASD form.</p>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = CachedSession(\n    \"NIST_ASD_cache\",\n    use_cache_dir=True,\n    expire_after=cache_expiry,\n    stale_if_error=True,\n    filter_fn=_check_response_success,\n    ignored_parameters=list(keys()) if strict_matching is False else None,\n)\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.species_expr","title":"species_expr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>species_expr = compile('spectra=([\\\\w\\\\+\\\\-\\\\%3]+)&amp;')\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.strict_matching","title":"strict_matching  <code>instance-attribute</code>","text":"<pre><code>strict_matching = strict_matching\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.use_polars","title":"use_polars  <code>instance-attribute</code>","text":"<pre><code>use_polars = False\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.__init__","title":"__init__","text":"<pre><code>__init__(\n    use_polars_backend=False,\n    cache_expiry=timedelta(weeks=1),\n    strict_matching=True,\n)\n</code></pre> <p>Initialize an instance that handles cached data lookup of the NIST ASD.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def __init__(self, use_polars_backend=False, cache_expiry=timedelta(weeks=1), strict_matching=True):\n    \"\"\"Initialize an instance that handles cached data lookup of the NIST ASD.\"\"\"\n    self.strict_matching = strict_matching\n    self.cache_expiry = cache_expiry\n    self.session = CachedSession(\n        \"NIST_ASD_cache\",\n        use_cache_dir=True,\n        expire_after=cache_expiry,\n        stale_if_error=True,\n        filter_fn=self._check_response_success,\n        ignored_parameters=list(self.query_params.keys()) if self.strict_matching is False else None,\n    )\n    if (use_polars_backend) &amp; (not POLARS_AVAILABLE):\n        warnings.warn(\"Cannot find `polars` as a backend, falling back to `pandas`\", stacklevel=2)\n        self.use_polars = False\n    else:\n        self.use_polars = use_polars_backend\n\n    self.known_species = self.list_cached_species()\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.create_dataframe","title":"create_dataframe","text":"<pre><code>create_dataframe(response) -&gt; pd.DataFrame | pl.DataFrame\n</code></pre> <p>Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def create_dataframe(self, response) -&gt; \"pd.DataFrame|pl.DataFrame\":\n    \"\"\"Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.\"\"\"\n    if self.use_polars:\n        return self._from_polars(response)\n    return self._from_pandas(response)\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.fetch","title":"fetch","text":"<pre><code>fetch(\n    species, wl_range=(170, 1000), **kwargs\n) -&gt; pd.DataFrame | pl.DataFrame | CachedResponse\n</code></pre> <p>Fetch information on a species from the ASD, first checking the cache.</p> <p>This supports loading multiple species in one go by using the same notation as the NIST ASD page.</p> <p>Note however that cache keys are computed for unique options for <code>species</code> and <code>wl_range</code>.</p> <p>This means that you won't get caching benefits by using different queries.</p> <p>In other words: the cache cannot deduplicate queries such as <code>ASD.fetch('H', (200,1000))</code> followed by <code>ASD.fetch('H I', (650,660))</code>.</p> <p>Both these operations will fetch data online and be stored as separate cache entries.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def fetch(self, species, wl_range=(170, 1000), **kwargs) -&gt; \"pd.DataFrame|pl.DataFrame|CachedResponse\":\n    \"\"\"Fetch information on a species from the ASD, first checking the cache.\n\n    This supports loading multiple species in one go by using the same notation as the NIST ASD page.\n\n    Note however that cache keys are computed for unique options for `species` and `wl_range`.\n\n    This means that you won't get caching benefits by using different queries.\n\n    In other words: the cache cannot deduplicate queries such as `ASD.fetch('H', (200,1000))` followed by `ASD.fetch('H I', (650,660))`.\n\n    Both these operations will fetch data online and be stored as separate cache entries.\n    \"\"\"\n    query_params = {\n        \"spectra\": species,\n        \"output_type\": 0,\n        \"low_w\": min(wl_range),\n        \"upp_w\": max(wl_range),\n        **self.query_params,\n    }\n    response = self.session.get(self.nist_url, params=query_params)\n\n    if response.status_code == 200:\n        return self.create_dataframe(response)\n    else:\n        print(f\"Error: Received status code {response.status_code}\")\n        print(response.url)\n        return response\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.get_all_cached","title":"get_all_cached","text":"<pre><code>get_all_cached() -&gt; pd.DataFrame | pl.DataFrame\n</code></pre> <p>Retrieve all cached data into a single dataframe.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def get_all_cached(self) -&gt; \"pd.DataFrame|pl.DataFrame\":\n    \"\"\"Retrieve all cached data into a single dataframe.\"\"\"\n    cached_frames = [self.create_dataframe(cached) for cached in self.session.cache.filter()]\n    if self.use_polars:\n        return pl.concat(cached_frames).unique()\n    return pd.concat(cached_frames).drop_duplicates().reset_index(drop=True)\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.list_cached_species","title":"list_cached_species","text":"<pre><code>list_cached_species() -&gt; list[str]\n</code></pre> <p>List all species in the cache, based on the string of the original query URL.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def list_cached_species(self) -&gt; list[str]:\n    \"\"\"List all species in the cache, based on the string of the original query URL.\"\"\"\n    return [\n        elem.replace(\"+\", \" \")\n        for u in self.session.cache.urls()\n        for elem in self.species_expr.search(u).group(1).split(\"%3B\")\n    ]\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.roman_to_int","title":"roman_to_int  <code>staticmethod</code>","text":"<pre><code>roman_to_int(roman: str) -&gt; int\n</code></pre> <p>Transform Roman numerals to integers.</p> <p>Does only support numerals including up to <code>L</code>.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>@staticmethod\ndef roman_to_int(roman: str) -&gt; int:\n    \"\"\"Transform Roman numerals to integers.\n\n    Does only support numerals including up to `L`.\n    \"\"\"\n    roman_numerals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50}\n    total = 0\n    previous = 0\n    for char in reversed(roman):\n        current_value = roman_numerals[char]\n        if current_value &lt; previous:\n            total -= current_value  # Subtract if the current value is less than the previous value\n        else:\n            total += current_value\n        previous = current_value\n    return total\n</code></pre>"},{"location":"reference/ASDCache/#ASDCache.SpectraCache.wn_to_n_refractive","title":"wn_to_n_refractive  <code>staticmethod</code>","text":"<pre><code>wn_to_n_refractive(wavenumbers: float) -&gt; float\n</code></pre> <p>Calculate the refractive index n in air for a transition, using the 5-term Sellmeier formula used by NIST.</p> <p>The used Sellmeier formula is the one from E.R. Peck and K. Reeder J. Opt. Soc. Am. 62, 958 (1972).</p> <p>This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.</p> <p>This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.</p> <p>See also the ASD documentation on the topic.</p> <p>Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>@staticmethod\ndef wn_to_n_refractive(wavenumbers: float) -&gt; float:\n    r\"\"\"Calculate the refractive index $n$ in air for a transition, using the 5-term Sellmeier formula used by NIST.\n\n    The used Sellmeier formula is the one from E.R. Peck and K. Reeder [J. Opt. Soc. Am. 62, 958 (1972)](http://dx.doi.org/10.1364/JOSA.62.000958).\n\n    This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.\n\n    This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.\n\n    See also [the ASD documentation on the topic](https://physics.nist.gov/PhysRefData/ASD/Html/lineshelp.html#Conversion%20between%20air%20and%20vacuum%20wavelengths).\n\n    Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.\n    \"\"\"\n    sigma = wavenumbers * 1e-4  # um^-1\n    return 1 + 1e-8 * (8060.51 + 2480990 / (132.274 - sigma**2) + 17455.7 / (39.32957 - sigma**2))\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/","title":"ASDCache","text":""},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache","title":"ASDCache.ASDCache","text":"<p><code>ASDcache</code> is a module to fetch data from the  NIST Atomic Spectra Database (ASD), utlizing caching for fast responses.</p> <p>To make the most use out of the cache, <code>ASDcache</code> is opinionated in the information it retrieves from the ASD; it always requests the same schema of information and locally computes additional fields.</p> <p>Data is initially fetched from the online published NIST page, using the tab-separated ASCII output format. The benefit of this format is that it is more 'machine readable' than the formatted ASCII of HTML options. This means it requires far less bespoke parsing to get rid of 'human readable' features such as repeated page column headers, or empty lines. To ensure a consistent schema of the retrieved data, lines are always retrieved as a function of wavelength, using <code>vacuum wavelength</code>, even between 200 to 2000 nm. Wavenumbers and Ritz wavelength will be included in the response.</p> <p>In the range 5000 \\mathrm{cm}^{-1}&lt;\\nu&lt;50000 \\mathrm{cm}^{-1} the air equivalent observed and Ritz wavelengths are calculated using the same Sellmeier equation as the NIST ASD (see here). This is consistent with the approach of the ASD.</p> <p>Each response from the NIST page is cached (1 week by default) on the local system. This makes it much faster to load the same data, even across different script runs and/or user programs/sessions. As an example: reading all spectra between 200 and 1000 nm can take over 2 minutes without using the cache, but can be as fast as 0.2 seconds using the <code>polars</code> backend. In addition, it means that an internet connection is not required after initial data fetching. The cached response is only updated upon succesfull retrieval of a new response of the NIST page. If unable to succesfully fetch new data, we fall back to a 'stale' cached response.</p> <p>The cache can be shared to another system, to give offline/airgapped systems access to the same data. To that end, the file <code>NIST_ASD_cache.sqlite</code> in the user's cache directory has to be copied over.</p> <p>The standard cache directories are as follows:</p> WindowsLinuxMacOS <p><code>%USERPROFILE%/AppData/Local</code></p> <p><code>~/.cache/http_cache/</code></p> <p><code>/Users/user/Library/Caches/http_cache/</code></p> <p>Queries to the NIST ASD are hashed by the keys (or parameters) of the requests. This means that any change to either one of these parameters, will result in a new cache entry, even if the returned data is equivalent.</p> <p>Classes:</p> Name Description <code>SpectraCache</code> <p>A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.</p> <p>Attributes:</p> Name Type Description <code>POLARS_AVAILABLE</code> <p>Check if <code>polars</code> is installed and available in the active environments</p>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.POLARS_AVAILABLE","title":"POLARS_AVAILABLE  <code>module-attribute</code>","text":"<pre><code>POLARS_AVAILABLE = True\n</code></pre> <p>Check if <code>polars</code> is installed and available in the active environments</p>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache","title":"SpectraCache","text":"<p>A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.</p> <p>The <code>ASDCache</code> instance acts as an access point to the cache, which stores responses on the local system in a SQLite database.</p> <p>Data retrieval from cache is much faster (order milliseconds) than fetching from the internet (order seconds), and avoids wastefull requests to the server.</p> <p>Cache time-to-live is one week by default.</p> <p>Since the NIST ASD is usually updated less frequently than that, this is a compromise between having the latest data, and overall fast performance.</p> <p>Note that the same cache is shared across different class-instances, thread-safety is not guaranteed.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize an instance that handles cached data lookup of the NIST ASD.</p> <code>create_dataframe</code> <p>Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.</p> <code>fetch</code> <p>Fetch information on a species from the ASD, first checking the cache.</p> <code>get_all_cached</code> <p>Retrieve all cached data into a single dataframe.</p> <code>list_cached_species</code> <p>List all species in the cache, based on the string of the original query URL.</p> <code>roman_to_int</code> <p>Transform Roman numerals to integers.</p> <code>wn_to_n_refractive</code> <p>Calculate the refractive index n in air for a transition, using the 5-term Sellmeier formula used by NIST.</p> <p>Attributes:</p> Name Type Description <code>cache_expiry</code> <code>column_order</code> <p>Fixed order of columns for consistent schema of data.</p> <code>known_species</code> <code>nist_url</code> <code>query_params</code> <p>Request parameters used by the NIST ASD form.</p> <code>session</code> <code>species_expr</code> <code>strict_matching</code> <code>use_polars</code> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>class SpectraCache:\n    \"\"\"A class acting as the entrypoint to retrieve data from the NIST Atomic Spectra Database that uses caching.\n\n    The `ASDCache` instance acts as an access point to the cache, which stores responses on the local system in a SQLite database.\n\n    Data retrieval from cache is much faster (order milliseconds) than fetching from the internet (order seconds), and avoids wastefull requests to the server.\n\n    Cache time-to-live is one week by default.\n\n    Since the NIST ASD is usually updated less frequently than that, this is a compromise between having the latest data, and overall fast performance.\n\n    Note that the same cache is shared across different class-instances, thread-safety is not guaranteed.\n    \"\"\"\n\n    nist_url = \"https://physics.nist.gov/cgi-bin/ASD/lines1.pl\"\n    species_expr = re.compile(r\"spectra=([\\w\\+\\-\\%3]+)&amp;\")\n    query_params = {\n        \"unit\": 1,\n        \"de\": 0,\n        \"plot_out\": 0,\n        \"I_scale_type\": 1,\n        \"format\": 3,\n        \"line_out\": 0,\n        \"remove_js\": \"on\",\n        \"no_spaces\": \"on\",\n        \"en_unit\": 0,\n        \"output\": 0,\n        \"bibrefs\": 1,\n        \"show_obs_wl\": 1,\n        \"show_calc_wl\": 1,\n        \"show_wn\": 1,\n        \"unc_out\": 1,\n        \"order_out\": 0,\n        \"show_av\": 3,  # 3: wavelength in vac, 2: wavelength in air\n        \"tsb_value\": 0,\n        \"A_out\": 0,\n        \"S_out\": \"on\",\n        \"f_out\": \"on\",\n        \"loggf_out\": \"on\",\n        \"intens_out\": \"on\",\n        \"conf_out\": \"on\",\n        \"term_out\": \"on\",\n        \"enrg_out\": \"on\",\n        \"J_out\": \"on\",\n        \"g_out\": \"on\",\n        \"diag_out\": \"on\",\n        \"allowed_out\": 1,\n        \"forbid_out\": 1,\n        \"submit\": \"Retrieve Data\",\n    }\n    \"\"\"Request parameters used by the NIST ASD form.\"\"\"\n    column_order = [\n        \"element\",\n        \"sp_num\",\n        \"obs_wl_vac(nm)\",\n        \"unc_obs_wl\",\n        \"obs_wl_air(nm)\",\n        \"ritz_wl_vac(nm)\",\n        \"unc_ritz_wl\",\n        \"ritz_wl_air(nm)\",\n        \"wn(cm-1)\",\n        \"intens\",\n        \"Aki(s^-1)\",\n        \"fik\",\n        \"S(a.u.)\",\n        \"log_gf\",\n        \"Acc\",\n        \"Ei(cm-1)\",\n        \"Ek(cm-1)\",\n        \"conf_i\",\n        \"term_i\",\n        \"J_i\",\n        \"conf_k\",\n        \"term_k\",\n        \"J_k\",\n        \"g_i\",\n        \"g_k\",\n        \"Type\",\n        \"tp_ref\",\n        \"line_ref\",\n    ]\n    \"\"\"Fixed order of columns for consistent schema of data.\"\"\"\n\n    def __init__(self, use_polars_backend=False, cache_expiry=timedelta(weeks=1), strict_matching=True):\n        \"\"\"Initialize an instance that handles cached data lookup of the NIST ASD.\"\"\"\n        self.strict_matching = strict_matching\n        self.cache_expiry = cache_expiry\n        self.session = CachedSession(\n            \"NIST_ASD_cache\",\n            use_cache_dir=True,\n            expire_after=cache_expiry,\n            stale_if_error=True,\n            filter_fn=self._check_response_success,\n            ignored_parameters=list(self.query_params.keys()) if self.strict_matching is False else None,\n        )\n        if (use_polars_backend) &amp; (not POLARS_AVAILABLE):\n            warnings.warn(\"Cannot find `polars` as a backend, falling back to `pandas`\", stacklevel=2)\n            self.use_polars = False\n        else:\n            self.use_polars = use_polars_backend\n\n        self.known_species = self.list_cached_species()\n\n    @staticmethod\n    def _check_response_success(response: \"CachedResponse\") -&gt; bool:\n        \"\"\"Validate that data has been fetched succesfully.\n\n        If this check fails, the cache should not update with this response, even when marked as stale.\n        \"\"\"\n        return (response.status_code == 200) &amp; (b\"Error Message\" not in response.content)\n\n    def list_cached_species(self) -&gt; list[str]:\n        \"\"\"List all species in the cache, based on the string of the original query URL.\"\"\"\n        return [\n            elem.replace(\"+\", \" \")\n            for u in self.session.cache.urls()\n            for elem in self.species_expr.search(u).group(1).split(\"%3B\")\n        ]\n\n    def fetch(self, species, wl_range=(170, 1000), **kwargs) -&gt; \"pd.DataFrame|pl.DataFrame|CachedResponse\":\n        \"\"\"Fetch information on a species from the ASD, first checking the cache.\n\n        This supports loading multiple species in one go by using the same notation as the NIST ASD page.\n\n        Note however that cache keys are computed for unique options for `species` and `wl_range`.\n\n        This means that you won't get caching benefits by using different queries.\n\n        In other words: the cache cannot deduplicate queries such as `ASD.fetch('H', (200,1000))` followed by `ASD.fetch('H I', (650,660))`.\n\n        Both these operations will fetch data online and be stored as separate cache entries.\n        \"\"\"\n        query_params = {\n            \"spectra\": species,\n            \"output_type\": 0,\n            \"low_w\": min(wl_range),\n            \"upp_w\": max(wl_range),\n            **self.query_params,\n        }\n        response = self.session.get(self.nist_url, params=query_params)\n\n        if response.status_code == 200:\n            return self.create_dataframe(response)\n        else:\n            print(f\"Error: Received status code {response.status_code}\")\n            print(response.url)\n            return response\n\n    def create_dataframe(self, response) -&gt; \"pd.DataFrame|pl.DataFrame\":\n        \"\"\"Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.\"\"\"\n        if self.use_polars:\n            return self._from_polars(response)\n        return self._from_pandas(response)\n\n    @classmethod\n    def _from_pandas(cls, response: \"CachedResponse\") -&gt; \"pd.DataFrame\":\n        r\"\"\"Transform a (cached) NIST ASD response into a pandas DataFrame.\n\n        Calculates the air equivalent wavelength from the vacuum wavelength using the same Sellmeier equation as the NIST ASD.\n\n        Note that this conversion is only performed for lines with $200 nm &lt; \\lambda &lt; 2000 nm$, like the ASD.\n\n        For lines outside of this range, the conversion falls back to their vacuum wavelength.\n        \"\"\"\n        schema = {\n            \"obs_wl_vac(nm)\": str,\n            \"ritz_wl_vac(nm)\": str,\n            \"wn(cm-1)\": float,\n            \"intens\": str,\n            \"Aki(s^-1)\": float,\n            \"fik\": float,\n            \"S(a.u.)\": float,\n            \"log_gf\": float,\n            \"Acc\": str,\n            \"Ei(cm-1)\": str,\n            \"Ek(cm-1)\": str,\n            \"conf_i\": str,\n            \"conf_k\": str,\n            \"term_i\": str,\n            \"term_k\": str,\n            \"g_i\": float,\n            \"g_k\": float,\n            \"J_i\": str,\n            \"J_k\": str,\n            \"\": str,\n        }\n        df = pd.read_csv(StringIO(response.text), sep=\"\\t\", dtype=schema)\n        for col in [\"obs_wl_vac(nm)\", \"ritz_wl_vac(nm)\", \"intens\", \"Ei(cm-1)\", \"Ek(cm-1)\"]:\n            df[col] = df.loc[:, col].str.extract(r\"([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\").astype(float)\n        df[\"Type\"] = df.loc[:, \"Type\"].astype(str).replace(\"nan\", \"E1\")\n        df[\"tp_ref\"] = df.loc[:, \"tp_ref\"].fillna(\"\")\n        df[\"obs_wl_air(nm)\"] = df[\"obs_wl_vac(nm)\"]\n        df[\"obs_wl_air(nm)\"] = df[df[\"wn(cm-1)\"].between(5000, 50000)][\"obs_wl_air(nm)\"] / cls.wn_to_n_refractive(\n            df[df[\"wn(cm-1)\"].between(5000, 50000)][\"wn(cm-1)\"]\n        )\n        df[\"ritz_wl_air(nm)\"] = df[\"ritz_wl_vac(nm)\"]\n        df[\"ritz_wl_air(nm)\"] = df[df[\"wn(cm-1)\"].between(5000, 50000)][\"ritz_wl_air(nm)\"] / cls.wn_to_n_refractive(\n            df[df[\"wn(cm-1)\"].between(5000, 50000)][\"wn(cm-1)\"]\n        )\n        df = df.drop([c for c in df.columns if \"Unnamed\" in c], axis=1).reset_index(drop=True)\n        if \"element\" not in df.columns:\n            expr = re.compile(r\"spectra=([\\w]+)\\+?([IVX]+)?\")\n            element, numeral = expr.search(response.url).groups()\n            df[\"element\"] = element\n            df[\"sp_num\"] = numeral\n            # cast roman numerals to int for consistency with queries with multiple ionization states, e.g. Ar I vs Ar I-II\n            df[\"sp_num\"] = df[\"sp_num\"].map(cls.roman_to_int)\n        df = (\n            df.assign(unc_obs_wl=df[\"unc_obs_wl\"].astype(float), unc_ritz_wl=df[\"unc_ritz_wl\"].astype(float))\n            if \"unc_obs_wl\" in df.columns\n            else df.assign(unc_obs_wl=np.nan, unc_ritz_wl=np.nan)\n        )\n        return df.loc[:, cls.column_order]\n\n    @classmethod\n    def _from_polars(cls, response: \"CachedResponse\") -&gt; \"pl.DataFrame\":\n        r\"\"\"Transform a (cached) NIST ASD response into a polars DataFrame.\n\n        Calculates the air equivalent wavelength from the vacuum wavelength using the same Sellmeier equation as the NIST ASD.\n\n        Note that this conversion is only performed for lines with $200 nm &lt; \\lambda &lt; 2000 nm$, like the ASD.\n\n        For lines outside of this range, the conversion falls back to their vacuum wavelength.\n        \"\"\"\n        schema = {\n            \"obs_wl_vac(nm)\": pl.String,\n            \"ritz_wl_vac(nm)\": pl.String,\n            \"wn(cm-1)\": pl.Float64,\n            \"intens\": pl.String,\n            \"Aki(s^-1)\": pl.Float64,\n            \"fik\": pl.Float64,\n            \"S(a.u.)\": pl.Float64,\n            \"log_gf\": pl.Float64,\n            \"Acc\": pl.String,\n            \"Ei(cm-1)\": pl.String,\n            \"Ek(cm-1)\": pl.String,\n            \"conf_i\": pl.String,\n            \"conf_k\": pl.String,\n            \"term_i\": pl.String,\n            \"term_k\": pl.String,\n            \"g_i\": pl.Float64,\n            \"g_k\": pl.Float64,\n            \"J_i\": pl.String,\n            \"J_k\": pl.String,\n            \"\": pl.String,\n        }\n        # annotation_chars_to_strip = \"(?i)()[]?*w,bGhilmprsq:+xzgacHd \"\n        df = (\n            pl.read_csv(\n                StringIO(response.text),\n                separator=\"\\t\",\n                schema_overrides=schema,\n                null_values=\"\",\n            )\n            .with_columns(\n                pl.col(\"obs_wl_vac(nm)\", \"Ei(cm-1)\", \"Ek(cm-1)\", \"intens\")\n                # .str.strip_chars(annotation_chars_to_strip).str.replace(\"&amp;dagger;\", \"\", literal=True)\n                .str.extract(r\"([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\")\n                # .str.extract(r\"([+-]?\\d*\\.?\\d+e[+-]?\\d+)\")\n                .replace(\"\", None)\n                .cast(pl.Float64),\n                pl.col(\"ritz_wl_vac(nm)\").str.strip_chars('\"+*').replace(\"\", None).cast(pl.Float64),\n                pl.col(\"S(a.u.)\").cast(pl.Float64),\n                pl.col(\"Type\").replace(None, \"E1\"),\n                pl.col(\"tp_ref\").replace(None, \"\"),\n            )\n            .drop([\"\"])\n        ).with_columns(\n            pl.when(pl.col(\"wn(cm-1)\").is_between(5000, 50000))\n            .then(\n                pl.col(\"obs_wl_vac(nm)\").cast(pl.Float64)\n                / pl.col(\"wn(cm-1)\").map_elements(cls.wn_to_n_refractive, return_dtype=pl.Float64)\n            )\n            .otherwise(pl.col(\"obs_wl_vac(nm)\"))\n            .cast(pl.Float64)\n            .alias(\"obs_wl_air(nm)\"),\n            pl.when(pl.col(\"wn(cm-1)\").is_between(5000, 50000))\n            .then(\n                pl.col(\"ritz_wl_vac(nm)\").cast(pl.Float64)\n                / pl.col(\"wn(cm-1)\").map_elements(cls.wn_to_n_refractive, return_dtype=pl.Float64)\n            )\n            .otherwise(pl.col(\"ritz_wl_vac(nm)\"))\n            .cast(pl.Float64)\n            .alias(\"ritz_wl_air(nm)\"),\n        )\n        if \"element\" not in df.columns:\n            expr = re.compile(r\"spectra=([\\w]+)\\+?([IVX]+)?\")\n            element, numeral = expr.search(response.url).groups()\n            # cast roman numerals to int for consistency with queries with multiple ionization states, e.g. Ar I vs Ar I-II\n            df = df.with_columns(\n                pl.lit(element).alias(\"element\"),\n                pl.lit(\"I\" if numeral is None else numeral)\n                .cast(pl.String)\n                .alias(\"sp_num\")\n                .map_elements(cls.roman_to_int, return_dtype=pl.Int64),\n            )\n        df = (\n            df.with_columns(pl.col(\"unc_obs_wl\").cast(pl.Float64), pl.col(\"unc_ritz_wl\").cast(pl.Float64))\n            if \"unc_obs_wl\" in df.columns\n            else df.with_columns(\n                pl.lit(None).cast(pl.Float64).alias(\"unc_obs_wl\"), pl.lit(None).cast(pl.Float64).alias(\"unc_ritz_wl\")\n            )\n        )\n\n        return df.select(*cls.column_order)\n\n    @staticmethod\n    def roman_to_int(roman: str) -&gt; int:\n        \"\"\"Transform Roman numerals to integers.\n\n        Does only support numerals including up to `L`.\n        \"\"\"\n        roman_numerals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50}\n        total = 0\n        previous = 0\n        for char in reversed(roman):\n            current_value = roman_numerals[char]\n            if current_value &lt; previous:\n                total -= current_value  # Subtract if the current value is less than the previous value\n            else:\n                total += current_value\n            previous = current_value\n        return total\n\n    @staticmethod\n    def wn_to_n_refractive(wavenumbers: float) -&gt; float:\n        r\"\"\"Calculate the refractive index $n$ in air for a transition, using the 5-term Sellmeier formula used by NIST.\n\n        The used Sellmeier formula is the one from E.R. Peck and K. Reeder [J. Opt. Soc. Am. 62, 958 (1972)](http://dx.doi.org/10.1364/JOSA.62.000958).\n\n        This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.\n\n        This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.\n\n        See also [the ASD documentation on the topic](https://physics.nist.gov/PhysRefData/ASD/Html/lineshelp.html#Conversion%20between%20air%20and%20vacuum%20wavelengths).\n\n        Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.\n        \"\"\"\n        sigma = wavenumbers * 1e-4  # um^-1\n        return 1 + 1e-8 * (8060.51 + 2480990 / (132.274 - sigma**2) + 17455.7 / (39.32957 - sigma**2))\n\n    def get_all_cached(self) -&gt; \"pd.DataFrame|pl.DataFrame\":\n        \"\"\"Retrieve all cached data into a single dataframe.\"\"\"\n        cached_frames = [self.create_dataframe(cached) for cached in self.session.cache.filter()]\n        if self.use_polars:\n            return pl.concat(cached_frames).unique()\n        return pd.concat(cached_frames).drop_duplicates().reset_index(drop=True)\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.cache_expiry","title":"cache_expiry  <code>instance-attribute</code>","text":"<pre><code>cache_expiry = cache_expiry\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.column_order","title":"column_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_order = [\n    \"element\",\n    \"sp_num\",\n    \"obs_wl_vac(nm)\",\n    \"unc_obs_wl\",\n    \"obs_wl_air(nm)\",\n    \"ritz_wl_vac(nm)\",\n    \"unc_ritz_wl\",\n    \"ritz_wl_air(nm)\",\n    \"wn(cm-1)\",\n    \"intens\",\n    \"Aki(s^-1)\",\n    \"fik\",\n    \"S(a.u.)\",\n    \"log_gf\",\n    \"Acc\",\n    \"Ei(cm-1)\",\n    \"Ek(cm-1)\",\n    \"conf_i\",\n    \"term_i\",\n    \"J_i\",\n    \"conf_k\",\n    \"term_k\",\n    \"J_k\",\n    \"g_i\",\n    \"g_k\",\n    \"Type\",\n    \"tp_ref\",\n    \"line_ref\",\n]\n</code></pre> <p>Fixed order of columns for consistent schema of data.</p>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.known_species","title":"known_species  <code>instance-attribute</code>","text":"<pre><code>known_species = list_cached_species()\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.nist_url","title":"nist_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nist_url = 'https://physics.nist.gov/cgi-bin/ASD/lines1.pl'\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.query_params","title":"query_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>query_params = {\n    \"unit\": 1,\n    \"de\": 0,\n    \"plot_out\": 0,\n    \"I_scale_type\": 1,\n    \"format\": 3,\n    \"line_out\": 0,\n    \"remove_js\": \"on\",\n    \"no_spaces\": \"on\",\n    \"en_unit\": 0,\n    \"output\": 0,\n    \"bibrefs\": 1,\n    \"show_obs_wl\": 1,\n    \"show_calc_wl\": 1,\n    \"show_wn\": 1,\n    \"unc_out\": 1,\n    \"order_out\": 0,\n    \"show_av\": 3,\n    \"tsb_value\": 0,\n    \"A_out\": 0,\n    \"S_out\": \"on\",\n    \"f_out\": \"on\",\n    \"loggf_out\": \"on\",\n    \"intens_out\": \"on\",\n    \"conf_out\": \"on\",\n    \"term_out\": \"on\",\n    \"enrg_out\": \"on\",\n    \"J_out\": \"on\",\n    \"g_out\": \"on\",\n    \"diag_out\": \"on\",\n    \"allowed_out\": 1,\n    \"forbid_out\": 1,\n    \"submit\": \"Retrieve Data\",\n}\n</code></pre> <p>Request parameters used by the NIST ASD form.</p>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = CachedSession(\n    \"NIST_ASD_cache\",\n    use_cache_dir=True,\n    expire_after=cache_expiry,\n    stale_if_error=True,\n    filter_fn=_check_response_success,\n    ignored_parameters=list(keys()) if strict_matching is False else None,\n)\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.species_expr","title":"species_expr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>species_expr = compile('spectra=([\\\\w\\\\+\\\\-\\\\%3]+)&amp;')\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.strict_matching","title":"strict_matching  <code>instance-attribute</code>","text":"<pre><code>strict_matching = strict_matching\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.use_polars","title":"use_polars  <code>instance-attribute</code>","text":"<pre><code>use_polars = False\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.__init__","title":"__init__","text":"<pre><code>__init__(\n    use_polars_backend=False,\n    cache_expiry=timedelta(weeks=1),\n    strict_matching=True,\n)\n</code></pre> <p>Initialize an instance that handles cached data lookup of the NIST ASD.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def __init__(self, use_polars_backend=False, cache_expiry=timedelta(weeks=1), strict_matching=True):\n    \"\"\"Initialize an instance that handles cached data lookup of the NIST ASD.\"\"\"\n    self.strict_matching = strict_matching\n    self.cache_expiry = cache_expiry\n    self.session = CachedSession(\n        \"NIST_ASD_cache\",\n        use_cache_dir=True,\n        expire_after=cache_expiry,\n        stale_if_error=True,\n        filter_fn=self._check_response_success,\n        ignored_parameters=list(self.query_params.keys()) if self.strict_matching is False else None,\n    )\n    if (use_polars_backend) &amp; (not POLARS_AVAILABLE):\n        warnings.warn(\"Cannot find `polars` as a backend, falling back to `pandas`\", stacklevel=2)\n        self.use_polars = False\n    else:\n        self.use_polars = use_polars_backend\n\n    self.known_species = self.list_cached_species()\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.create_dataframe","title":"create_dataframe","text":"<pre><code>create_dataframe(response) -&gt; pd.DataFrame | pl.DataFrame\n</code></pre> <p>Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def create_dataframe(self, response) -&gt; \"pd.DataFrame|pl.DataFrame\":\n    \"\"\"Create a dataframe from the (cached) NIST ASD response, using the chosen backend at class instantiation.\"\"\"\n    if self.use_polars:\n        return self._from_polars(response)\n    return self._from_pandas(response)\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.fetch","title":"fetch","text":"<pre><code>fetch(\n    species, wl_range=(170, 1000), **kwargs\n) -&gt; pd.DataFrame | pl.DataFrame | CachedResponse\n</code></pre> <p>Fetch information on a species from the ASD, first checking the cache.</p> <p>This supports loading multiple species in one go by using the same notation as the NIST ASD page.</p> <p>Note however that cache keys are computed for unique options for <code>species</code> and <code>wl_range</code>.</p> <p>This means that you won't get caching benefits by using different queries.</p> <p>In other words: the cache cannot deduplicate queries such as <code>ASD.fetch('H', (200,1000))</code> followed by <code>ASD.fetch('H I', (650,660))</code>.</p> <p>Both these operations will fetch data online and be stored as separate cache entries.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def fetch(self, species, wl_range=(170, 1000), **kwargs) -&gt; \"pd.DataFrame|pl.DataFrame|CachedResponse\":\n    \"\"\"Fetch information on a species from the ASD, first checking the cache.\n\n    This supports loading multiple species in one go by using the same notation as the NIST ASD page.\n\n    Note however that cache keys are computed for unique options for `species` and `wl_range`.\n\n    This means that you won't get caching benefits by using different queries.\n\n    In other words: the cache cannot deduplicate queries such as `ASD.fetch('H', (200,1000))` followed by `ASD.fetch('H I', (650,660))`.\n\n    Both these operations will fetch data online and be stored as separate cache entries.\n    \"\"\"\n    query_params = {\n        \"spectra\": species,\n        \"output_type\": 0,\n        \"low_w\": min(wl_range),\n        \"upp_w\": max(wl_range),\n        **self.query_params,\n    }\n    response = self.session.get(self.nist_url, params=query_params)\n\n    if response.status_code == 200:\n        return self.create_dataframe(response)\n    else:\n        print(f\"Error: Received status code {response.status_code}\")\n        print(response.url)\n        return response\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.get_all_cached","title":"get_all_cached","text":"<pre><code>get_all_cached() -&gt; pd.DataFrame | pl.DataFrame\n</code></pre> <p>Retrieve all cached data into a single dataframe.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def get_all_cached(self) -&gt; \"pd.DataFrame|pl.DataFrame\":\n    \"\"\"Retrieve all cached data into a single dataframe.\"\"\"\n    cached_frames = [self.create_dataframe(cached) for cached in self.session.cache.filter()]\n    if self.use_polars:\n        return pl.concat(cached_frames).unique()\n    return pd.concat(cached_frames).drop_duplicates().reset_index(drop=True)\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.list_cached_species","title":"list_cached_species","text":"<pre><code>list_cached_species() -&gt; list[str]\n</code></pre> <p>List all species in the cache, based on the string of the original query URL.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>def list_cached_species(self) -&gt; list[str]:\n    \"\"\"List all species in the cache, based on the string of the original query URL.\"\"\"\n    return [\n        elem.replace(\"+\", \" \")\n        for u in self.session.cache.urls()\n        for elem in self.species_expr.search(u).group(1).split(\"%3B\")\n    ]\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.roman_to_int","title":"roman_to_int  <code>staticmethod</code>","text":"<pre><code>roman_to_int(roman: str) -&gt; int\n</code></pre> <p>Transform Roman numerals to integers.</p> <p>Does only support numerals including up to <code>L</code>.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>@staticmethod\ndef roman_to_int(roman: str) -&gt; int:\n    \"\"\"Transform Roman numerals to integers.\n\n    Does only support numerals including up to `L`.\n    \"\"\"\n    roman_numerals = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50}\n    total = 0\n    previous = 0\n    for char in reversed(roman):\n        current_value = roman_numerals[char]\n        if current_value &lt; previous:\n            total -= current_value  # Subtract if the current value is less than the previous value\n        else:\n            total += current_value\n        previous = current_value\n    return total\n</code></pre>"},{"location":"reference/ASDCache/ASDCache/#ASDCache.ASDCache.SpectraCache.wn_to_n_refractive","title":"wn_to_n_refractive  <code>staticmethod</code>","text":"<pre><code>wn_to_n_refractive(wavenumbers: float) -&gt; float\n</code></pre> <p>Calculate the refractive index n in air for a transition, using the 5-term Sellmeier formula used by NIST.</p> <p>The used Sellmeier formula is the one from E.R. Peck and K. Reeder J. Opt. Soc. Am. 62, 958 (1972).</p> <p>This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.</p> <p>This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.</p> <p>See also the ASD documentation on the topic.</p> <p>Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.</p> Source code in <code>src/ASDCache/ASDCache.py</code> <pre><code>@staticmethod\ndef wn_to_n_refractive(wavenumbers: float) -&gt; float:\n    r\"\"\"Calculate the refractive index $n$ in air for a transition, using the 5-term Sellmeier formula used by NIST.\n\n    The used Sellmeier formula is the one from E.R. Peck and K. Reeder [J. Opt. Soc. Am. 62, 958 (1972)](http://dx.doi.org/10.1364/JOSA.62.000958).\n\n    This formula is fitted to data in the range of 185 nm to 1700 nm for  air at 15 \u00b0C, 101 325 Pa pressure, with 0.033 % CO2.\n\n    This is the same formula used by the NIST ASD to calculate air wavelengths in the interval of 200 nm to 2000 nm.\n\n    See also [the ASD documentation on the topic](https://physics.nist.gov/PhysRefData/ASD/Html/lineshelp.html#Conversion%20between%20air%20and%20vacuum%20wavelengths).\n\n    Using this refractive index, air equivalent wavelengths consistent with the ASD can be calculated, without the need to query them separately.\n    \"\"\"\n    sigma = wavenumbers * 1e-4  # um^-1\n    return 1 + 1e-8 * (8060.51 + 2480990 / (132.274 - sigma**2) + 17455.7 / (39.32957 - sigma**2))\n</code></pre>"}]}